---
title: "hw1"
author: "Korotkov Vitaliy"
date: "2024-10-19"
output:
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Работа с данными

### Загрузка данных
```{r}
data.df <- read.table("http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat", header=FALSE)
cat("Количество строк: ", nrow(data.df), "\nКоличество столбцов: ", ncol(data.df))
```

### Имена колонок
```{r}
colnames(data.df)
```

### Значение 5 строки 7 столбца
```{r}
data.df[5, 7]
```

### Вторая строка
```{r}
data.df[2, ]
```

### Замена заголовков столбцов
```{r}
names(data.df) <- c("year", "month", "day", seq(0, 23))
```
Данная строка заменяет заголовки столбцов на "year", "month", "day", и 0, 1, 2, ..., 23, которые соответствуют часу дня, в который были зафиксированы осадки.

Начало таблицы:
```{r}
head(data.df)
```

Конец таблицы:
```{r}
tail(data.df)
```
Последние 24 колонки представляют собой количество осадков по каждому часу дня.

### Добавление колонки и построение гистограммы
Добавим новую колонку `daily`, которая будет содержать сумму осадков за день (по всем часам):
```{r}
data.df$daily <- rowSums(data.df[, 4:27])
head(data.df)
```

Построим гистограмму для новой колонки `daily`:
```{r}
hist(data.df$daily, main = "Количество осадков по дням", xlab = "Осадки", ylab = "Количество дней")
```

Мы видим, что в данных есть некорректные значения (-999), что приводит к неправильной интерпретации гистограммы.

### Исправление ошибок в данных и создание нового датафрейма
Удалим некорректные значения (-999):
```{r}
fixed.df <- data.df[data.df$daily > 0, ]
```

Построим гистограмму для исправленного датафрейма:
```{r}
hist(fixed.df$daily, main = "Количество осадков по дням (исправленные данные)", xlab = "Осадки", ylab = "Количество дней", breaks = 80)
```

Новая гистограмма более корректна, так как она построена на данных без ошибочных значений.

## Синтаксис и типизирование

### Пример 1
```{r}
v <- c("4", "8", "15", "16", "23", "42")
max(v)
```
Функция `max()` ищет максимальное значение вектора. Поскольку все элементы вектора являются строками, они сравниваются лексикографически, по первому символу.

```{r}
sort(v)
```
Функция `sort()` сортирует строки в алфавитном порядке, опять же лексикографически.

```{r}
# sum(v)
```
Функция `sum()` не работает для строковых векторов, выдаст ошибку.

### Пример 2
```{r}
# v2 <- c("5", 7, 12)
# v2[2] + v2[3]
```
Хотя элементы вектора представлены как числа, вектор смешанного типа автоматически преобразуется в строковый. Следовательно, сложение вызовет ошибку.

```{r}
df3 <- data.frame(z1="5", z2=7, z3=12)
df3[1, 2] + df3[1, 3]
```
В данном примере элементы второго и третьего столбца могут быть сложены, так как они являются числовыми.

```{r}
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
```
Сложение значений из второго и четвертого элементов списка работает, так как оба являются числами.

```{r}
# l4[2] + l4[4]
```
Это вызовет ошибку, так как обращение `l4[2]` и `l4[4]` возвращает список, а не числовые значения.

## Работа с функциями и операторами

### Последовательности чисел
Числа от 1 до 10000 с инкрементом 372:
```{r}
seq(1, 10000, by=372)
```

Числа от 1 до 10000 длиной 50:
```{r}
seq(1, 10000, length.out=50)
```

### Функция `rep()`
```{r}
rep(1:5, times=3)
```
Этот код повторяет весь вектор `1:5` три раза.

```{r}
rep(1:5, each=3)
```
Этот код повторяет каждый элемент вектора три раза.